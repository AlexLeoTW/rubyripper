#!/usr/bin/env ruby
#    Rubyripper - A secure ripper for Linux/BSD/OSX
#    Copyright (C) 2007 - 2011 Bouke Woudstra (boukewoudstra@gmail.com)
#
#    This file is part of Rubyripper. Rubyripper is free software: 
#    you can redistribute it and/or modify it under the terms of 
#    the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>

# set the directory of the local installation
$localdir = File.expand_path(File.dirname(File.dirname(__FILE__)))

# Put the local lib directory on top of the ruby default lib search path
$:.insert(0, File.expand_path('../../lib', __FILE__))

# Try to find the rubyripper lib files
begin
  require 'rubyripper/base'
  require 'rubyripper/preferences/main'
  require 'rubyripper/gtk2/shortMessage'
rescue LoadError
  puts 'The rubyripper lib files can\'t be found!'
  puts 'Perhaps you need to add the directory to the RUBYLIB variable?'
  exit()
end

# Try to load the gtk2 files
begin
  require 'gtk2'
rescue LoadError
  puts "The ruby-gtk2 library could not be found. Is it installed?"; exit()
end

# The class defines the Rubyripper window.
# It has a variable frame in it, that can be
# replaced with other Gtk2 classes.

class GraphicalUserInterface
attr_reader :instances

  def initialize(prefs=nil, short=nil)
    @prefs = prefs ? prefs : Preferences::Main.instance
    @shortMessage = short ? short : ShortMessage.new()
  end
  
  def start
    @prefs.load()
    prepareMainWindow()
    setupMainContainer()
    showWelcomeMessage()
    @gtkWindow.show_all()
    Thread.new{scanDisc()}
    Gtk.main
  end
  
  def update(modus, value=false)
    @updateThread.join if @updateThread != nil # one gui update at a time please
    @updateThread = Thread.new do
      if modus == "error"
        @shortMessage.show_message(value)
        changeDisplay(@shortMessage)
        sleep(5)
        changeDisplay(@instances['GtkMetadata'])
        @buttons.each{|button| button.sensitive = true}
      elsif modus == "ripping_progress"
        @instances['RipStatus'].updateProgress('ripping', value)
      elsif modus == "encoding_progress"
        @instances['RipStatus'].updateProgress('encoding', value)
      elsif modus == "log_change"
        @instances['RipStatus'].logChange(value)
      elsif modus == "dir_exists"
        @instances['DirExists'] = DirExists.new(self, @rubyripper, value)
        changeDisplay(@instances['DirExists'])
      elsif modus == "finished"
        showSummary(value)
        if @settings['eject'] == true
          @buttontext[2].text =_("Close tray")
          @buttonicons[2].stock = Gtk::Stock::GOTO_TOP
        end
      else
        puts _("Ehh.. There shouldn't be anything else. WTF?")
        puts _("Secret modus = %s") % [modus]
      end
    end
  end
  
  private

  # set the name, icon and size
  def prepareMainWindow
    @gtkWindow = Gtk::Window.new('Rubyripper')
    setIconForWindow()
    @gtkWindow.set_default_size(530, 440) #width, height
  end
  
  # setup the central container
  def setupMainContainer
    @mainHbox = Gtk::HBox.new(false,5)
    createButtonsLeftside()
    setButtonsLeftsideSignals()
    @mainHbox.pack_start(@vbuttonbox1,false,false,0)
    @gtkWindow.add(@mainHbox)
  end
  
  # launch the welcome message and announce the scanning
  def showWelcomeMessage
    @shortMessage.welcome()
    changeDisplay(@shortMessage)
  end
   
  def scanDisc
    @buttons.each{|button| button.sensitive = false}
    if @gtkDisc ; @gtkDisc.refresh
    else
      require 'rubyripper/gtk2/gtkDisc'
      @gtkDisc = GtkDisc.new()
      @gtkDisc.start()
    end
    
    scanDiscResults()
  end
  
  # TODO cancel tocscan
  # TODO freedb multiple choice
  def scanDiscResults   
    if @gtkDisc.error.nil?
      showAbleToEjectDisc()
      @buttons.each{|button| button.sensitive = true}
      changeDisplay(@gtkDisc)
    else
      @shortMessage.showError(@gtkDisc.error)
      @buttons[0..2].each{|button| button.sensitive = true} ; @buttons[4].sensitive = true
      changeDisplay(@shortMessage)
    end
  end
  
  # change the icon and text of the button
  def showAbleToEjectDisc
    if @buttontext[2].text != _("Open tray")
      @buttontext[2].set_text('_'+_("Open tray"),true)
      @buttonicons[2].stock = Gtk::Stock::GOTO_BOTTOM
    end
  end
  
  # The central function that manages the display on the right side
  def changeDisplay(object)
    # reset exit button
    if @currentInstance == "RipStatus"
      @buttontext[4].set_text('_' + _("Exit"), true)
      @buttonicons[4].stock = Gtk::Stock::QUIT
    end

    @mainHbox.remove(@mainHbox.children[-1]) if @currentInstance

    @currentInstance = object.class.to_s #the name of the instance type
    @mainHbox.add(object.display)

    # update the Exit button to Abort button
    if @currentInstance == "RipStatus"
      @buttontext[4].set_text('_' + _("Abort"), true)
      @buttonicons[4].stock = Gtk::Stock::CANCEL
    end

    object.display.show_all()
  end
   
  # find the icon
  def setIconForWindow
    iconPaths = [File.expand_path('../..', __FILE__), "/usr/local/share/icons/hicolor/128x128/apps"]
    iconPaths.each do |path|
      if File.exist?(file = File.join(path, 'rubyripper.png'))
        @gtkWindow.icon = Gdk::Pixbuf.new(file)
        break
      end
    end
  end
  
  # the leftside menu that is always visible
  def createButtonsLeftside
    @vbuttonbox1 = Gtk::VButtonBox.new #child of @mainHbox
    @buttons = [Gtk::Button.new, Gtk::Button.new, Gtk::Button.new, Gtk::Button.new, Gtk::Button.new]
    @buttons.each{|button| button.sensitive = false}
    @buttontext = [Gtk::Label.new('_'+_('Preferences'),true), Gtk::Label.new('_'+_("Scan drive"), true), Gtk::Label.new('_'+_("Open tray"),true), Gtk::Label.new('_'+_("Rip cd now!"),true), Gtk::Label.new('_'+_("Exit"),true)]
    @buttonicons = [Gtk::Image.new(Gtk::Stock::PREFERENCES, Gtk::IconSize::LARGE_TOOLBAR), Gtk::Image.new(Gtk::Stock::REFRESH, Gtk::IconSize::LARGE_TOOLBAR), Gtk::Image.new(Gtk::Stock::GOTO_BOTTOM, Gtk::IconSize::LARGE_TOOLBAR), Gtk::Image.new(Gtk::Stock::CDROM, Gtk::IconSize::LARGE_TOOLBAR), Gtk::Image.new(Gtk::Stock::QUIT, Gtk::IconSize::LARGE_TOOLBAR)]
    @vboxes = [Gtk::VBox.new, Gtk::VBox.new, Gtk::VBox.new,  Gtk::VBox.new, Gtk::VBox.new]

    index = 0
    @vboxes.each do |vbox|
      vbox.add(@buttonicons[index])
      vbox.add(@buttontext[index])
      @buttons[index].add(@vboxes[index])
      index += 1
    end
    @buttons.each{|button| @vbuttonbox1.pack_start(button,false,false)}
  end

  def setButtonsLeftsideSignals
    @gtkWindow.signal_connect("destroy") {savePreferences(); exit()}
    @gtkWindow.signal_connect("delete_event") {savePreferences(); exit()}
    @buttons[0].signal_connect("activate") {@buttons[0].signal_emit("released")}
    @buttons[0].signal_connect("released") {savePreferences(); showDiscOrPreferences()}
    @buttons[1].signal_connect("clicked") {savePreferences(); scanDisc()}
    @buttons[2].signal_connect("clicked") {savePreferences(); handle_tray()}
    @buttons[3].signal_connect("clicked") {savePreferences(); startRip()}
    @buttons[4].signal_connect("clicked") {exitButton()}
  end
  
  # TODO
  def something        
    @settingsClass = Settings.new()
    @settings = @settingsClass.settings
    @lock = Monitor.new()
    @updateThread = nil
    scanDrive()
  end
  
  def exitButton
    if @buttontext[4].text == _("Exit")
      savePreferences(); exit()
    else
      Thread.new do
        @rubyripper.cancelRip() # Let rubyripper stop ripping and encoding
        @rubyripper = nil # kill the instance
        @rubyripperThread.exit() # kill the thread
        @buttons.each{|button| button.sensitive = true}
        changeDisplay(@instances['GtkMetadata'])
      end
    end
  end

  def cancelTocScan
    `killall cdrdao 2>&1`
  end

  def savePreferences
    if @currentInstance == 'GtkPreferences'
      @buttontext[0].set_text('_'+_('Preferences'),true)
      @buttonicons[0].stock = Gtk::Stock::PREFERENCES
      @gtkPrefs.save
    end
  end

  def exit
    `killall cdparanoia 2>&1`
    Gtk.main_quit
  end
  
  def startupPreferences
    if not @gtkPrefs
      require 'rubyripper/gtk2/gtkPreferences'
      @gtkPrefs = GtkPreferences.new()
      @gtkPrefs.start()
    end
    @gtkPrefs.display.page = 0
    changeDisplay(@gtkPrefs) 
  end

  def showDiscOrPreferences
    @buttons.each{|button| button.sensitive = false}
    Thread.new do
      if @currentInstance != 'GtkPreferences'
        @buttontext[0].set_text('_'+_('Disc info'), true)
        @buttonicons[0].stock = Gtk::Stock::INFO
        startupPreferences()
        @buttons[0..2].each{|button| button.sensitive = true}
        @buttons[3].sensitive = true if @gtkDisc && @gtkDisc.error.nil?
        @buttons[4].sensitive = true
      elsif @gtkDisc
        changeDisplay(@gtkDisc)
        @buttons.each{|button| button.sensitive = true}
      else
        scanDisc()
      end
    end
  end

  #Fetch the cddb info if user wants to
  def handleFreedb(choice = false)
    if choice == false
      @settings['cd'].md.freedb(@settings, @settings['first_hit'])
    elsif choice == -1
      @settings['cd'].md.freedbChoice(0)
    else
      @settings['cd'].md.freedbChoice(choice)
    end

    status = @settings['cd'].md.status

    if status == true #success
      @instances['GtkMetadata'].updateMetadata()
      if @currentInstance != 'GtkMetadata'
        changeDisplay(@instances['GtkMetadata'])
      end
    elsif status[0] == "choices"
      @instances['MultipleFreedbHits'] = MultipleFreedbHits.new(status[1], self)
      changeDisplay(@instances['MultipleFreedbHits'])
    elsif status[0] == "networkDown" || status[0] == "noMatches" || status[0] == "unknownReturnCode" || status[0] == "NoAudioDisc"
      update("error", status[1])
    else
      puts "Unknown error with Metadata class."
    end
  end

  def handle_tray
    @buttons.each{|button| button.sensitive = false}
    Thread.new do
      if installed('eject')
        if @buttontext[2].text == _("Open tray")
          @instances['GtkMetadata'] = false
          @instances['ShortMessage'].open_tray(@settings['cdrom'])
          changeDisplay(@instances['ShortMessage'])
          cancelTocScan()
          `eject #{@settings['cdrom']}` # spit the cd out
          @buttontext[2].set_text('_'+_("Close tray"),true)
          @buttonicons[2].stock = Gtk::Stock::GOTO_TOP
          @instances['ShortMessage'].ask_for_disc
          @buttons[0..2].each{|button| button.sensitive = true} ; @buttons[4].sensitive = true
        else
          @instances['ShortMessage'].close_tray(@settings['cdrom'])
          changeDisplay(@instances['ShortMessage'])
          `eject --trayclose #{@settings['cdrom']}` # close the tray
          @buttontext[2].set_text('_'+_("Open tray"),true)
          @buttonicons[2].stock = Gtk::Stock::GOTO_BOTTOM
          scanDrive()
        end
      else
        @instances['ShortMessage'].no_eject_found
        changeDisplay(@instances['ShortMessage'])
        @buttons[0..2].each{|button| button.sensitive = true} ; if @instances['GtkMetadata'] ; @buttons[3].sensitive = true end ; @buttons[4].sensitive = true
      end
    end
  end

  def startRip
    @buttons[0..3].each{|button| button.sensitive = false}
    @instances['GtkMetadata'].save_updates(@settings['image'])
    @settings['tracksToRip'] = @instances['GtkMetadata'].tracks_to_rip

    @rubyripper = Rubyripper.new(@settings, self) # start a new instance, keep it out the Thread for later callbacks (yet_to_implement)

    status = @rubyripper.settingsOk
    puts "status = #{status}" if @settings['debug']
    if status == true
      doRip()
    else
      @buttons[0..3].each{|button| button.sensitive = true}
      update(status[0], status[1])
    end
  end

  def doRip
    @rubyripperThread = Thread.new do
      @buttons[0..3].each{|button| button.sensitive = false}
      if @instances['RipStatus'] == false
        @instances['RipStatus'] = RipStatus.new()
      else
        @instances['RipStatus'].reset
      end

      changeDisplay(@instances['RipStatus'])
      @rubyripper.startRip # fire away the start shot
    end
  end

  def showSummary(succes)
    @buttons[0..3].each{|button| button.sensitive = true}
    @instances['Summary'] = Summary.new(@settings['editor'], @settings['filemanager'], @rubyripper.outputDir, @rubyripper.summary, succes)
    changeDisplay(@instances['Summary'])
    @instances['RipStatus'].reset()
    @rubyripper = false # some resetting of variables, I suspect some optimization of ruby otherwise would prevent refreshing
  end


end

if __FILE__ == $0
  Gtk.init
  app = GraphicalUserInterface.new()
  app.start()
end
